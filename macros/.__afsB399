// This Macro Plots Information About Missed LCTs In the Spacer Bar Region.
#include "ChamberSerial.h"
#include "TMath.h"

int SpacerLoss(int n){

  // Allow Vector Types Included In Data
  gInterpreter->GenerateDictionary("std::vector<std::vector<int> >","vector");
  gInterpreter->GenerateDictionary("std::vector<std::vector<std::vector<int> > >","vector");

  // Open File and Load Tree
  TFile inFile("../blocks/cscDigiBlock" + (std::string) n + ".root");
  TTree* myTree = (TTree*) inFile.Get("CSCDigiTree");
 
  // Generate Canvases
  TCanvas *c1 = new TCanvas("c1","Canvas",0,0,450,450);
  TCanvas *c2 = new TCanvas("c2","Canvas",516,0,450,450);
  TCanvas *c3 = new TCanvas("c3","Canvas",0,501,450,450);
  TCanvas *c4 = new TCanvas("c4","Canvas",516,501,450,450);

  // Declaration Of Variables and Branches
  Int_t Nseg;
  Double_t eta;
  bool os;
  Double_t Pt;
  std::vector<int> *segEc;
  std::vector<int> *segSt;
  std::vector<int> *segRi;
  std::vector<int> *segCh;
  std::vector<int> *rhId;
  std::vector<int> *lctId;
  std::vector<int> *alctId;
  std::vector<int> *clctId;
  std::vector<int> *compId;
  std::vector<int> *wireId;
  std::vector<int> *wireLay; 
  std::vector<std::vector<int> > *wireGrp;
  std::vector<std::vector<std::vector<int> > > *wireTimeOn;
 
  Long64_t nEntries = myTree.GetEntriesFast(); // Number of Muons Recorded

  TBranch *b_Nseg;
  TBranch *b_eta;
  TBranch *b_os;
  TBranch *b_Pt;
  TBranch *b_segEc;
  TBranch *b_segSt;
  TBranch *b_segRi;
  TBranch *b_segCh;
  TBranch *b_rhId;
  TBranch *b_lctId;
  TBranch *b_alctId;
  TBranch *b_clctId;
  TBranch *b_compId;
  TBranch *b_wireId;
  TBranch *b_wireLay;
  TBranch *b_wireGrp;
  TBranch *b_wireTimeOn;

  int nMu = 0;
  int nOn = 0;
  int nTw = 0;
  int nTh = 0;
  int nFo = 0;

  // Set Branch Addresses
  myTree->SetBranchAddress("Nseg",&Nseg,&b_Nseg);
  myTree->SetBranchAddress("os",&os,&b_os);
  myTree->SetBranchAddress("Pt",&Pt,&b_Pt);
  myTree->SetBranchAddress("eta",&eta,&b_eta);
  myTree->SetBranchAddress("segEc",&segEc,&b_segEc);
  myTree->SetBranchAddress("segSt",&segSt,&b_segSt);
  myTree->SetBranchAddress("segRi",&segRi,&b_segRi);
  myTree->SetBranchAddress("segCh",&segCh,&b_segCh);
  myTree->SetBranchAddress("rhId",&rhId,&b_rhId);
  myTree->SetBranchAddress("lctId",&lctId,&b_lctId);
  myTree->SetBranchAddress("alctId",&alctId,&b_alctId);
  myTree->SetBranchAddress("clctId",&clctId,&b_clctId);
  myTree->SetBranchAddress("compId",&compId,&b_compId);
  myTree->SetBranchAddress("wireId",&wireId,&b_wireId);
  myTree->SetBranchAddress("wireLay",&wireLay,&b_wireLay);
  myTree->SetBranchAddress("wireGrp",&wireGrp,&b_wireGrp);
  myTree->SetBranchAddress("wireTimeOn",&wireTimeOn,&b_wireTimeOn);

  // Create Histograms
  TH1I *numSegs = new TH1I("numSegs","Number of Segments",3,1,4);
  for (Int_t i = 1; i < 4; ++i) numSegs->GetXaxis()->SetBinLabel(i,Form("%i",i));
  numSegs->SetMinimum(0);

  TH1I *miSt = new TH1I("miSt","Missing Station",4,1,5);
  for (Int_t i = 1; i < 5; ++i) miSt->GetXaxis()->SetBinLabel(i,Form("%i",i));
  miSt->SetMinimum(0);

  TH1I *nuMi = new TH1I("nuMi","Number of Missing Layers",6,0,6);
  for (Int_t i = 1; i < 7; ++i) nuMi->GetXaxis()->SetBinLabel(i,Form("%i",i-1));
  nuMi->SetMinimum(0);

  TH1D *miEtOn = new TH1D("miEtOn","Eta of Missing LCTs - Station One",140,1.1,2.5);
  miEtOn->SetMinimum(0);

  TH1D *miEtTw = new TH1D("miEtTw","Eta of Missing LCTs - Station Two",140,1.1,2.5);
  miEtTw->SetMinimum(0);

  TH1D *miEtTh = new TH1D("miEtTh","Eta of Missing LCTs - Station Three",140,1.1,2.5);
  miEtTh->SetMinimum(0);

  TH1D *miEtFo = new TH1D("miEtFo","Eta of Missing LCTs - Station Four",140,1.1,2.5);
  miEtFo->SetMinimum(0);

  TH1D *efNuOn = new TH1D("efNuOn","Station 1 Efficiency",140,1.1,2.5);
  TH1D *efDeOn = new TH1D("efDeOn","Station 1 Efficiency",140,1.1,2.5);

  TH1D *efNuTw = new TH1D("efNuTw","Station 2 Efficiency",140,1.1,2.5);
  TH1D *efDeTw = new TH1D("efDeTw","Station 2 Efficiency",140,1.1,2.5);

  TH1D *efNuTh = new TH1D("efNuTh","Station 3 Efficiency",140,1.1,2.5);
  TH1D *efDeTh = new TH1D("efDeTh","Station 3 Efficiency",140,1.1,2.5);

  TH1D *efNuFo = new TH1D("efNuFo","Station 4 Efficiency",140,1.1,2.5);
  TH1D *efDeFo = new TH1D("efDeFo","Station 4 Efficiency",140,1.1,2.5);
 
  // Plots in Theta
  TH1D *thNuOnFr = new TH1D("thNuOnFr","Station 1 Efficiency",140,10,34);
  TH1D *thDeOnFr = new TH1D("thDeOnFr","Station 1 Efficiency",140,10,34);
  TH1D *thNuOnRe = new TH1D("thNuOnRe","Station 1 Efficiency",140,10,34);
  TH1D *thDeOnRe = new TH1D("thDeOnRe","Station 1 Efficiency",140,10,34);

  TH1D *thNuTwFr = new TH1D("thNuTwFr","Station 2 Efficiency",140,10,34);
  TH1D *thDeTwFr = new TH1D("thDeTwFr","Station 2 Efficiency",140,10,34);
  TH1D *thNuTwRe = new TH1D("thNuTwRe","Station 2 Efficiency",140,10,34);
  TH1D *thDeTwRe = new TH1D("thDeTwRe","Station 2 Efficiency",140,10,34);

  TH1D *thNuThFr = new TH1D("thNuThFr","Station 3 Efficiency",140,10,34);
  TH1D *thDeThFr = new TH1D("thDeThFr","Station 3 Efficiency",140,10,34);
  TH1D *thNuThRe = new TH1D("thNuThRe","Station 3 Efficiency",140,10,34);
  TH1D *thDeThRe = new TH1D("thDeThRe","Station 3 Efficiency",140,10,34);

  TH1D *thNuFoFr = new TH1D("thNuFoFr","Station 4 Efficiency",140,10,34);
  TH1D *thDeFoFr = new TH1D("thDeFoFr","Station 4 Efficiency",140,10,34);
  TH1D *thNuFoRe = new TH1D("thNuFoRe","Station 4 Efficiency",140,10,34);
  TH1D *thDeFoRe = new TH1D("thDeFoRe","Station 4 Efficiency",140,10,34);

  // Loop Over Muons
  for (int muon = 0; muon < nEntries; ++muon){
    myTree->GetEntry(muon); 
    if (!os) continue;
    if (Pt < 10) continue;
    double aeta = TMath::Abs(eta);
    if (aeta < 1.2 || aeta > 2.4) continue;
    double theta = 360/TMath::Pi()*TMath::ATan(exp(-aeta));
    nMu++;
    // Loop Over Segments
    for (int iseg = 0; iseg < (int) Nseg; ++iseg){
      // Calculate Chamber Serial
      int EC = segEc->at(iseg);
      int ST = segSt->at(iseg);
      int RI = segRi->at(iseg);
      int CH = segCh->at(iseg);
      int serial = ChamberSerial(EC,ST,RI,CH);
      // Determine if Segment Has LCT
      bool has_lct = false;
      for (int ilct = 0; ilct < lctId.size(); ++ilct){
        if (lctId->at(ilct) == serial){
	  has_lct = true;
          break;
        }
      }
      bool has_rh = false;
      for (int rh = 0; rh < rhId.size(); ++rh){
        if (rhId->at(rh) == serial){
          has_rh = true;
          break;
        }
      }
      switch (ST){
        case 1: efDeOn->Fill(aeta); if (CH % 2) thDeOnFr->Fill(theta);
                else thDeOnRe->Fill(theta); break;
        case 2: efDeTw->Fill(aeta); if (CH % 2) thDeTwFr->Fill(theta);
                else thDeTwRe->Fill(theta); break;
        case 3: efDeTh->Fill(aeta); if (CH % 2) thDeThFr->Fill(theta);
                else thDeThRe->Fill(theta); break;
        case 4: efDeFo->Fill(aeta); if (CH % 2) thDeFoFr->Fill(theta);
                else thDeFoRe->Fill(theta); break;
      }
      if (has_lct){
        switch (ST){
          case 1: efNuOn->Fill(aeta); if (CH % 2) thNuOnFr->Fill(theta);
                  else thNuOnRe->Fill(theta); break;
          case 2: efNuTw->Fill(aeta); if (CH % 2) thNuTwFr->Fill(theta);
                  else thNuTwRe->Fill(theta); break;
          case 3: efNuTh->Fill(aeta); if (CH % 2) thNuThFr->Fill(theta);
                  else thNuThRe->Fill(theta); break;
          case 4: efNuFo->Fill(aeta); if (CH % 2) thNuFoFr->Fill(theta);
                  else thNuFoRe->Fill(theta); break;
        }
      }
    }       
  }
  efNuOn->Divide(efDeOn);
  efNuTw->Divide(efDeTw);
  efNuTh->Divide(efDeTh);
  efNuFo->Divide(efDeFo);

  thNuOnFr->Divide(thDeOnFr);
  thNuTwFr->Divide(thDeTwFr);
  thNuThFr->Divide(thDeThFr);
  thNuFoFr->Divide(thDeFoFr);
  thNuOnRe->Divide(thDeOnRe);
  thNuTwRe->Divide(thDeTwRe);
  thNuThRe->Divide(thDeThRe);
  thNuFoRe->Divide(thDeFoRe);

  efNuOn->SetMinimum(0.7);
  efNuTw->SetMinimum(0.7);
  efNuTh->SetMinimum(0.7);
  efNuFo->SetMinimum(0.7);

  thNuOnFr->SetMinimum(0.7);
  thNuTwFr->SetMinimum(0.7);
  thNuThFr->SetMinimum(0.7);
  thNuFoFr->SetMinimum(0.7);
  thNuOnFr->SetMinimum(0.7);
  thNuTwFr->SetMinimum(0.7);
  thNuThFr->SetMinimum(0.7);
  thNuFoFr->SetMinimum(0.7);

  std::cout << nMu << endl << nOn << " " << nTw << " " << nTh << " " << nFo << endl;

  // Display Histograms
  c1->cd();
  thNuOnFr->SetLineColor(2);
  thNuOnFr->Draw();
  thNuOnRe->SetLineColor(4);
  thNuOnRe->Draw("same");
  c2->cd();
  thNuTwFr->SetLineColor(2);
  thNuTwFr->Draw();
  thNuTwRe->SetLineColor(4);
  thNuTwRe->Draw("same");
  c3->cd();
  thNuThFr->SetLineColor(2);
  thNuThFr->Draw();
  thNuThRe->SetLineColor(4);
  thNuThRe->Draw("same");
  c4->cd();
  thNuFoFr->SetLineColor(2);
  thNuFoFr->Draw();
  thNuFoRe->SetLineColor(4);
  thNuFoRe->Draw("same");

  // Save Histograms to File
  TFile *outFile = new TFile("../analysis/outFile" + n + ".root","NEW");
  thNuOnFr->Write("thNuOnFr");
  thNuTwFr->Write("thNuTwFr");
  thNuThFr->Write("thNuThFr");
  thNuFoFr->Write("thNuFoFr");
  thNuOnRe->Write("thNuOnRe");
  thNuTwRe->Write("thNuTwRe");
  thNuThRe->Write("thNuThRe");
  thNuFoRe->Write("thNuFoRe");
  outFile->Write();
  outFile->Close();
}
